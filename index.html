    <!-- <ul class="badge-list">
    ${badgesByCollection.map(badge => 
        `<li>${badge.name}: ${badge.count}</li>`
    ).join('')}
</ul> -->
<!-- Da mettere alla riga 419 -->

<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
    <title>BadgeChecker</title>

</head>
<body>
    <header class="header">
        <div class="header-content">
            <a href="#" class="logo">BadgeChecker</a>
        </div>
    </header>
    <div class="page-container">
        <main class="main-content">
            <h1>Check NFT Badges</h1>
            
            <div class="form-group">
                <label for="walletAddress">Wallet Address</label>
                <input type="text" id="walletAddress" placeholder="Enter wallet address (0x...)" value="">
            </div>
            
            <div class="form-group">
                <div class="buttons-container">
                    <button class="button button-scan" onclick="scanAllContracts()">Scan Wallet</button>
                </div>               
            </div>
            
            <div class="loading" id="loading">
                <p>Scanning wallet contents...</p>
            </div>
            
            <div class="error" id="error"></div>
            
            <div id="results"></div>
        </main>

        <aside class="sidebar">
            <div class="sidebar-card">
                <h2>Tip Me</h2>
                <p style="margin-bottom: 1rem; font-size: 0.875rem; color: #64748b;">Support the development of BadgeChecker by sending a tip.</p>
                <div class="wallet-list">
                    <div class="wallet-item">
                        <span class="wallet-address" id="wallet1">0xc46bd9e23f603f2d7f3c46cdd0267caaffadf35e0cdde156c3328a4a3dd9d642</span>
                        <span class="wallet-label">SUI</span>
                    </div>
                    <div class="wallet-item">
                        <span class="wallet-address" id="wallet2">GRZFYyigEh4tXnLnpRodK2bnGbUp46AWJnEJNy3HNN1v</span>
                        <span class="wallet-label">Solana</span>
                    </div>
                    <div class="wallet-item">
                        <span class="wallet-address" id="wallet3">0x2C4554946fb9082f27585e9e147e19E86166C343</span>
                        <span class="wallet-label">Ethereum</span>
                    </div>
                </div>
            </div>
            
            <div class="sidebar-card">
                <h2>About</h2>
                <p style="margin-bottom: 1rem; font-size: 0.9375rem;">BadgeChecker allows you to verify NFT badges in your wallet. Scan your wallet to see which badges you own and which ones you're missing.</p>
                <p style="font-size: 0.875rem; color: #64748b;">This tool supports Ethereum, Binance Smart Chain, and other EVM-compatible chains.</p>
            </div>
        </aside>
    </div>

    <script>
        // Include the original scripts
        const DEFAULT_CONTRACTS = [
            { address: "0x9d83A657581A966aDf1c346dAfEE3EBe258EC26D", name: "Mithraeum: Badge" },
            { address: "0x7e058E9eeb81758F80049d0F2c1C1A7b47919697", name: "OmniHub" },
            { address: "0x890a19A1Dd75AAEcc4eDFce4685bb59C8ABEe78A", name: "Posse"},
            { address: "0x2A21B17E366836e5FFB19bd47edB03b4b551C89d", name: "OG badge"},
            { address: "0x1eC6AACC79f3c4817d7fea2268e1c54C6b2662Fb", name: "Owlto badge"},
            { address: "0x4591D540B692CBeD60Db7781B7683910f7a3BF8C", name: "NFT2Me"},
            { address: "0x066ABA7c3520e300113C0515FF41c084eE0c95Ea", name: "Sonus"},
            { address: "0x38bD4363b7Cd4040fAC6EEa5eF5d38E934AebD65", name: "CoPump"},
            { address: "0xCA707D22E248740aDaA9C63580F7A35201B18d30", name: "UneWeb"},
            { address: "0x11B2876C58cFb7501Db60d0112AF8A8EfEB0A81D", name: "KyoFinance"},
            { address: "0x3a634e6f8C2bf2C5894722B908d99e3cF9C62eD3", name: "Sake"},
        ];

        const API_BASE_URL = "https://soneium.blockscout.com/api/v2";
        const NFT_TYPES = "ERC-721%2CERC-404%2CERC-1155";
        const IMAGE_PLACEHOLDER = "/api/placeholder/200/200";
        
        // Stato globale dell'applicazione
        const appState = {
            contracts: [...DEFAULT_CONTRACTS]
        };

        // Initialize the application
        window.onload = function() {
            updateContractsList(appState.contracts);
            
            // Add event listeners for wallet address copying
            document.querySelectorAll('.wallet-address').forEach(item => {
                item.addEventListener('click', () => {
                    const text = item.innerText;
                    navigator.clipboard.writeText(text)
                        .then(() => {
                            alert('Wallet address copied to clipboard');
                        })
                        .catch(err => {
                            console.error('Error copying text: ', err);
                        });
                });
            });
        };

        // Validation functions
        function isValidAddress(address) {
            return /^0x[a-fA-F0-9]{40}$/.test(address);
        }

        function isContractDuplicate(address, contractsList) {
            return contractsList.some(c => c.address.toLowerCase() === address.toLowerCase());
        }

        function validateScanInputs(walletAddress, contracts) {
            if (!walletAddress) {
                return { valid: false, message: 'Please enter a wallet address' };
            }
            
            if (!isValidAddress(walletAddress)) {
                return { valid: false, message: 'Invalid wallet address format' };
            }
            
            if (contracts.length === 0) {
                return { valid: false, message: 'Add at least one contract to scan' };
            }
            
            return { valid: true };
        }

        // UI Functions
        function updateContractsList(contracts) {
            const contractsList = document.getElementById('contractsList');
            contractsList.innerHTML = '';
            
            if (contracts.length === 0) {
                contractsList.innerHTML = '<p style="padding: 0.75rem 1rem; color: #64748b;">No contracts added yet</p>';
                return;
            }
            
            contracts.forEach((contract, index) => {
                const contractDiv = document.createElement('div');
                contractDiv.className = 'contract-item';
                
                const isDefaultContract = DEFAULT_CONTRACTS.some(
                    dc => dc.address.toLowerCase() === contract.address.toLowerCase()
                );
                
                const removeButton = isDefaultContract ? '' : 
                    `<span class="contract-remove" onclick="removeContract(${index})">âœ•</span>`;
                
                contractDiv.innerHTML = `
                    <span class="contract-address">${contract.name}</span>
                    ${removeButton}
                `;
                contractsList.appendChild(contractDiv);
            });
        }

        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.innerHTML = message;
            errorDiv.style.display = 'block';
        }

        function hideError() {
            document.getElementById('error').style.display = 'none';
        }

        function toggleLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }

        // Contract management
        function addContract() {
            const contractInput = document.getElementById('contractAddress');
            const contractAddress = contractInput.value.trim();
            
            if (!contractAddress) {
                showError('Please enter a valid contract address');
                return;
            }
            
            if (!isValidAddress(contractAddress)) {
                showError('Invalid contract address format');
                return;
            }
            
            if (isContractDuplicate(contractAddress, appState.contracts)) {
                showError('This contract is already in the list');
                return;
            }
            
            appState.contracts.push({ address: contractAddress, name: `NFT #${appState.contracts.length + 1}` });
            updateContractsList(appState.contracts);
            contractInput.value = '';
            
            hideError();
        }

        function removeContract(index) {
            appState.contracts.splice(index, 1);
            updateContractsList(appState.contracts);
        }

        // API Functions
        async function fetchNFTCollections(walletAddress) {
            const apiUrl = `${API_BASE_URL}/addresses/${walletAddress}/nft/collections?type=${NFT_TYPES}`;
            
            const response = await fetch(apiUrl);
            if (!response.ok) {
                throw new Error(`API error: ${response.status} ${response.statusText}`);
            }
            
            return await response.json();
        }

        async function fetchTokenInfo(contractAddress) {
            const apiUrl = `${API_BASE_URL}/tokens/${contractAddress}`;
            
            try {
                const response = await fetch(apiUrl);
                if (!response.ok) {
                    console.warn(`Couldn't fetch token info for ${contractAddress}: ${response.status}`);
                    return null;
                }
                
                return await response.json();
            } catch (error) {
                console.warn(`Error fetching token info for ${contractAddress}:`, error);
                return null;
            }
        }

        function organizeCollectionsByContract(collectionsData) {
            if (!collectionsData.items || collectionsData.items.length === 0) {
                return {};
            }
            
            const collectionsByContract = {};
            
            for (const collection of collectionsData.items) {
                if (collection.token && collection.token.address) {
                    const contractAddress = collection.token.address.toLowerCase();
                    collectionsByContract[contractAddress] = collection;
                }
            }
            
            return collectionsByContract;
        }

        // Media helpers
        function isVideoFile(url) {
            if (!url) return false;
            return url.toLowerCase().endsWith('.mp4') || 
                   url.toLowerCase().endsWith('.webm') ||
                   url.toLowerCase().includes('media.mp4');
        }

        function getLocalImageUrl(contractName) {
            const safeFileName = contractName.replace(/[^a-zA-Z0-9]/g, '');
            console.log(safeFileName);
            return `./${safeFileName}.jpg`;
        }

        // Results display
        function createResultsHTML(contracts, collectionsByContract) {
            let html = `<h2>Scan Results</h2>`;
            let foundAny = false;
            let totalBadges = 0;
            let badgesByCollection = [];
            let missingBadges = [];
            
            const expectedBadgeCounts = {
                'Owlto badge': 6,
                'Mithraeum: Badge': 1,
                'OmniHub': 1,
                'Posse': 1,
                'OG badge': 1,
                'NFT2Me': 1,
                'Sonus': 1,
                'CoPump': 1,
                'UneWeb': 1,
                'KyoFinance': 1,
                'Sake': 1
            };
            
            for (const contractObj of contracts) {
                const contractAddress = contractObj.address;
                const matchingCollection = collectionsByContract[contractAddress.toLowerCase()];
                const collectionName = contractObj.name;
                
                if (!matchingCollection) {
                    const image = getLocalImageUrl(contractObj.name)
                    console.log(image)
                    html += `
                        <div class="collection-header">
                            
                            <h3 class="collection-name">${collectionName} (Missing NFT)</h3>
                            <p class="collection-address">${contractAddress}</p>
                        </div>
                    `;
                    
                    if (expectedBadgeCounts[collectionName]) {
                        missingBadges.push({
                            name: collectionName,
                            count: 0,
                            expected: expectedBadgeCounts[collectionName],
                            missing: expectedBadgeCounts[collectionName]
                        });
                    }
                    continue;
                }
                
                foundAny = true;
                let collectionBadgeCount = 0;
                
                if (matchingCollection.token_instances && matchingCollection.token_instances.length > 0) {
                    collectionBadgeCount = matchingCollection.token_instances.length;
                    totalBadges += collectionBadgeCount;
                    
                    const tokenName = matchingCollection.token.name;
                    badgesByCollection.push({
                        name: tokenName,
                        count: collectionBadgeCount
                    });
                    
                    if (expectedBadgeCounts[tokenName]) {
                        const expected = expectedBadgeCounts[tokenName];
                        const missing = expected - collectionBadgeCount;
                        
                        if (missing > 0) {
                            missingBadges.push({
                                name: tokenName,
                                count: collectionBadgeCount,
                                expected: expected,
                                missing: missing
                            });
                        }
                    }
                }
                
                html += `
                    <div class="collection-header">
                        <h3 class="collection-name">${matchingCollection.token.name} (${matchingCollection.token.symbol})</h3>
                        <p class="collection-address">${matchingCollection.token.address}</p>
                    </div>
                `;
                
                if (matchingCollection.token_instances && matchingCollection.token_instances.length > 0) {
                    for (const instance of matchingCollection.token_instances) {
                        const localImageUrl = getLocalImageUrl(matchingCollection.token.name);
                        
                        let mediaUrl;
                        if (instance.image_url && 
                            instance.image_url !== "null" && 
                            instance.image_url !== null) {
                            mediaUrl = instance.image_url;
                        } else if (instance.metadata?.animation_url && 
                            instance.metadata.animation_url !== "null" && 
                            instance.metadata.animation_url !== null) {
                            mediaUrl = instance.metadata.animation_url;
                        } else {
                            mediaUrl = localImageUrl;
                        }
                        
                        const name = instance.metadata?.name || matchingCollection.token.name;
                        
                        let mediaElement;
                        if (isVideoFile(mediaUrl)) {
                            mediaElement = `
                                <div class="video-container">
                                    <video class="nft-video" autoplay loop muted>
                                        <source src="${mediaUrl}" type="video/mp4">
                                        Your browser does not support video playback.
                                    </video>
                                </div>
                            `;                
                        } else {
                            mediaElement = `<img src="${mediaUrl}" alt="${name}" class="nft-image" onerror="this.onerror=null; this.src='${IMAGE_PLACEHOLDER}'; this.alt='NFT image placeholder';">`;
                        }
                        
                        html += `
                            <div class="nft-item">
                                <div class="nft-header">
                                    ${mediaElement}
                                    <div class="nft-details">
                                        <h3 class="nft-name">${name}</h3>
                                        <p><strong>Token ID:</strong> ${instance.id}</p>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                } else {
                    html += `<p style="margin-bottom: 1.5rem;">No tokens found for this collection.</p>`;
                }
            }
            
            if (foundAny) {
                let missingBadgesHTML = '';
                if (missingBadges.length > 0) {
                    missingBadgesHTML = `
                        <div class="missing-badges">
                            <h3>Missing Badges:</h3>
                            <ul class="badge-list">
                                ${missingBadges.map(badge => 
                                `<li>${badge.name}: ${badge.count}/${badge.expected} (missing ${badge.missing})</li>`
                                ).join('')}
                                </ul>
                            </div>
                        `;
                }
            html = `
                    <div class="badge-summary">
                        <p class="badge-total">Total Badges Found: ${totalBadges}</p>
                    
                        ${missingBadgesHTML}
                    </div>
                ` + html;
            } else {
                html = `
                    <div class="badge-summary">
                        <p class="badge-total">No NFT badges found in wallet.</p>
                    </div>
                ` + html;
            }
            
            return html;
        }

        // Main scanning function
        async function scanAllContracts() {
            const walletAddressInput = document.getElementById('walletAddress');
            const walletAddress = walletAddressInput.value.trim();
            
            const validation = validateScanInputs(walletAddress, appState.contracts);
            if (!validation.valid) {
                showError(validation.message);
                return;
            }
            
            hideError();
            toggleLoading(true);
            
            try {
                const collections = await fetchNFTCollections(walletAddress);
                const collectionsByContract = organizeCollectionsByContract(collections);
                
                const resultsContainer = document.getElementById('results');
                resultsContainer.innerHTML = createResultsHTML(appState.contracts, collectionsByContract);
                
            } catch (error) {
                console.error('Error scanning wallet:', error);
                showError(`Error scanning wallet: ${error.message}`);
            } finally {
                toggleLoading(false);
            }
        }
    </script>
    <script>
    document.querySelectorAll('.wallet-address').forEach(item => {
        item.addEventListener('click', () => {
            const text = item.innerText;
            navigator.clipboard.writeText(text)
                .then(() => {
                    alert('Wallet address copied to clipboard');
                })
                .catch(err => {
                    console.error('Error copying text: ', err);
                });
        });
    });
    </script>
</body>
</html>
